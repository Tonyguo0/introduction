### ref: https://github.com/reactjs/react.dev/pull/5487#issuecomment-1409720741

Hi everyone.

We know this has been a pain point for a while, and we are working on a proposal to address it. Since this pull request was intended to start a discussion, this sounds like a good time to provide some background on our thinking about the future of Create React App. We want to be clear about our reasoning and the tradeoffs we're considering, so this is going to be a long comment with several sections. If you're feeling impatient, scroll to the last section for our proposed way forward.


## Why Create React App exists
To provide the historical context for this discussion, I'd like to revisit the story of Create React App and retrace its evolution.

When we released Create React App in 2016, the tooling landscape was fragmented and not integrated. If you were adding React to an existing app, you'd add a `<script>` tag or an import from npm, and then adjust your existing build tooling configuration. But if you were creating a new app that's built just with React from scratch, there was no clear way to do it.

Before Create React App, you had to install a bunch of tools and wire them up together, provide the right presets to use JSX, configure them differently for development and production environments, provide the right settings for asset caching, configure the linter, and so on. This was very tricky to do correctly. People coped with this by creating and sharing "boilerplate" repositories that you could clone. However, that created a different problem: once you cloned the boilerplate and adjusted it for your project, it was hard to pull updates. Your project setup would get stale, and you'd either give up on updating or spend a lot of effort getting all tools to work together again. In a fast-moving ecosystem, this was very difficult.

Create React App solved this by combining several tools under one package, choosing a reasonable default configuration, and then papering over all the little incompatibilities between the tools. Now, if you wanted to start a new project with React, there was a single clear recommended way to do that! Then, every once in a while, you'd update this package, and get all the underlying tooling updates "for free". This model became so popular that there's an entire category of tools working this way today. Vite is indeed one of the best tools out there that share a similar vision—and, in some ways, takes it further.

The goal of Create React App was to provide the best way to start a new React web app for the majority of React users. It supported a curated set of features that work together. Over time, the "baseline" of what it offers out of the box would expand as we figure out the right tradeoffs. For example, we've added an overlay for runtime errors. We've added support for different styling options. We've added Fast Refresh by default, which allowed you to save your component's code and see the changes without losing the state. This was a huge milestone for the default React developer experience. In general, since Create React App had full control over the compilation pipeline, adding compilation-related features for everyone was easy.

Having a curated setup like this remains valuable to the ecosystem. When React Hooks came out, we added the React Hooks lint rules to the default setup. In addition to being an easy way to start a project, Create React App also allowed the React team to deploy non-trivial tooling changes (Fast Refresh support, React Hooks lint rules) to the broadest possible audience. It would be difficult to roll out these tooling changes so widely if there was no popular template curated by the React team.

## The problems with Create React App
As the years passed, Create React App has stagnated. Many pointed out in this thread that it is slower than the alternatives, and doesn't support some popular tools that people want to use today. In principle, we could fix these issues. For example, we could update the internals of Create React App to use a faster bundler, or even to use Vite internally. Or we could suggest people to migrate from Create React App to something like Vite. However, there is a much deeper issue we want to address.

By design, Create React App produces a purely client-side app. This means that every app created with it contains an empty HTML file and a `<script>` tag with React and your application bundle. When the empty HTML file loads, the browser waits for the React code and your entire application bundle to download. This might take a while on low-bandwidth connections, and the user does not see anything on the screen at all while this is happening. Then, your application code loads. Now the browser needs to run all of it, which may be slow on underpowered devices. At last, at this point the user sees something on the screen — but often you'll also need to load some data. So your code sends a request to load some data, and the user is waiting for it to come back. Finally, the data loads, the components re-render with the data, and the user sees the final result.

This is quite inefficient, though it's hard to do better if you run React on the client only. Compare this to a server framework like Rails: a server would start the data fetch immediately, and then generate the page with all the data. Or take a static build-time framework like Jekyll that does the same, but during the build, and produces an HTML+JS+CSS bundle you can deploy to a static hosting. In both cases, the user would see the HTML file with all the information instead of a blank file waiting for the scripts to load. HTML is the cornerstone of the web — so why does creating a "React app" produce an empty HTML file? Why are we not taking advantage of the most basic feature of the web—the ability to see content quickly before all the interactive code loads? Why do we wait to start loading the data until after all the client-side code has finished loading?

Create React App solved only one side of the problem. It provided a good (at the time!) development experience, but it didn't impose enough structure to help you leverage the strong sides of the web for a good user experience. You could try to solve these problems yourself, but that would involve "ejecting" and significantly customizing your setup, which defeated the point of Create React App. Every truly efficient React setup was custom, different, and unachievable with Create React App.

These user experience problems are not specific to Create React App. They are not even specific to React. For example, apps created from the Vite homepage templates for Preact, Vue, Lit, and Svelte suffer from all of the same problems. These problems are inherent to purely client-side apps with no static site generation (SSG) or server-side rendering (SSR).

Although the Facebook.com rewrite from Hack/XHP rendering to React could not have shipped without SSR (which ended up being critical for performance), the problems described above don't uniquely affect large apps like Facebook. Quite the opposite! If you think about many apps developed fully in React, you'll find all kinds of content-oriented apps that would benefit from SSG or SSR. Portfolios, blogs, newspapers, e-commerce shops — it simply doesn't make sense for them to serve empty HTML files. This is why we always suggested to use SSG-capable React frameworks for content-oriented sites.

## The rise of React frameworks
Some people might prefer to not build fully in React, and that's a valid option. For example, you could generate HTML pages on the server or during the build with a different tool like Jekyll or Astro. This solves the problem of empty HTML files, but you have to mix two rendering technologies (e.g. Jekyll templates for the "outer" part of the page and React components for the "inner" part). The more interactivity you want to add with time, the more noticeable this technological split becomes.

This split does not only hurt the developer experience — the user experiences suffers too. With tools that are truly HTML-centered and don't take full advantage of React, every page navigation becomes a full page reload, blowing away all the client-side state. Today, many users expect smooth in-app navigation (assuming it's done in a correct and accessible way) rather than '90s style full page reloads. Similarly, many developers prefer to build their app using a single rendering model instead of mixing two different ones. People want to build their entire apps with React. And we want to enable them to.

If you build entire apps with React, being able to use SSG/SSR is important. The lack of support for them in Create React App is glaring. But it's not the only area where Create React App is behind. After years of innovation in the ecosystem, many other problems now have mature solutions for React. For example, let's look at network waterfalls and bundle size.

Even if your app doesn't benefit from SSG or SSR as much as content-oriented sites do, it likely suffers from network waterfalls. If you fetch "on mount", your first data fetch doesn't even start until all the code has loaded and your components have rendered. That's a waterfall — it could be done in parallel if your app "knew" how to start fetching while the code is still loading. On navigation, if a parent and a child component both need to fetch something, that creates even worse waterfalls. When we talk about React performance, there's no escaping the fact that for so many apps, waterfalls are the performance bottleneck. To solve these waterfalls, you need to integrate data fetching with routing, which Create React App doesn't do.

Unlike React, which has a fixed bundle size, your application code keeps growing with every new feature and extra dependency you add. If you deploy often, your app can become very slow to load on every usage because it'll always have to load all code. There are a few ways you can solve this problem. You could say "no" to features, but this doesn't always work. You could move some code to run on the server or during the build (if your tooling allows that). Ideally, you would also split code by route: if a dashboard page needs to render a chart, there is no need to load that chart's entire implementation on the account billing page. However, if you try to do code splitting manually, you'll often make performance worse. For example, if you lazily load the chart, but the chart loads its data "on mount", you have just introduced yet another network waterfall. Solving this well requires integrating data fetching with routing and bundling, which Create React App doesn't do.

React itself is only a library. It does not dictate how to do routing or data fetching. Neither does Create React App. Unfortunately, this means that neither React alone nor Create React App, as originally designed, can solve these problems. As you can see, this isn't about a single missing feature. These features — server-side rendering and static generation, data fetching, bundling, and routing — are interconnected. When Create React App came out, React was very new, and there was still a lot left to figure out about each of these features should work in isolation, let alone how to best put them together.

Times changed. Now it's getting increasingly difficult to recommend a solution where you are locked into not having these features. Even if you don't use all of them immediately, they should be available for you when you need them. You shouldn't have to migrate to a different template and restructure all of your code to take advantage of them. Similarly, not all data fetching or code splitting needs to be route-based. But it's a good default that should be available to most React apps.

Although you could integrate all these pieces yourself, it is hard to do well. Just like when Create React App itself integrated several concerns related to compilation, tools like Next.js, Gatsby, and Remix went further — and integrated compilation with rendering, routing, and data fetching. This category of tools that integrates compilation, rendering, routing and data fetching is known as "frameworks". (Or, if you prefer to call React itself a framework, you might call them "metaframeworks"). These frameworks impose some opinions about structuring your app in order to provide a much better user experience. Many developers also find it ergonomic to have recommended scalable built-in solutions for routing and data fetching.

## React as an architecture
We like the flexibility of React. You can use React to build a single button, or you can use it to build an entire app. You can use it to build an internal dashboard inside a twenty-year old Perl website, or you can make a hybrid SSG/SSR e-commerce website using React for the entire thing. This flexibility is essential, and we know our users love it too. It isn't going away.

However, we also want to encourage the best possible defaults we can for new apps fully built with React. It would be nice if the default suggested way to create React apps supported features like SSG and SSR, automatic code splitting, no client-server waterfalls, route prefetching, navigation preserving client UI state, and other features that enable a great user experience. At the very least, the default suggested way to create React apps should not be totally locked out of these features due to an inherently client-only architecture that doesn't integrate the right concerns to enable them.

This is an opportunity. For frameworks, the challenge is to integrate these concerns with great performance and ergonomics. However, there was also a challenge there for React, too. We realized that the best way we can help React frameworks to deliver great user experiences is by focusing on the underlying primitives in React itself. There are unique things that React itself can do at the rendering layer which supercharge what frameworks can do at all other layers. For example, as with <Suspense>, a single React API can unlock a whole range of framework optimizations for a framework behind the scenes.

This is why we find it helpful to think of React as two things.

React is a library. This library provides some APIs that let you define and compose components together. React is also an architecture. It provides the building blocks that let the framework authors take full advantage of its rendering model. You can use React without a framework. But we want to make sure that if you use it with a framework, the framework is able to take the best advantage of React itself. Many of the features we've been building for the past few years (<Suspense>, useTransition, streaming APIs like renderToPipeableStream, and experimental Server Components) are framework-oriented. They let frameworks take full advantage of React by integrating bundling, routing, and data fetching with it.

You can already see some of these features being adopted in Next 13, Gatsby 5, and Remix 1.11. There is still a lot to do, and some of this work is in the process of graduating out of the experimental stage (so documentation is still sparse). Still, we're excited to see our multi-year efforts pay off and empower React frameworks (and their users) to ship faster apps by default.

Which brings us to the next point.

## One library, many frameworks
There's more than a single React framework. And that's good.

Despite concerns about the churn, the React ecosystem is better for having many players. There are multiple competing data fetching solutions and routing solutions. The options get better with every year. It shouldn't be surprising that there are also multiple solutions that integrate routing, data fetching, rendering and compilation — i.e., multiple React frameworks.

We would like to keep it that way. However, we would also like to encourage convergence where it is possible and benefits the React ecosystem. For example, different frameworks may use different mechanisms to load data. However, if they all adopt <Suspense> for loading indicators, our higher-level features on top of <Suspense> will work with all frameworks. We are still working to finalize and document APIs for frameworks, but we want to empower them to take the best from React.

Some projects will never fit into any popular framework's mold, and that's okay. Maybe you're developing an internal dashboard that needs to integrate with a PHP site, and none of the frameworks let you do that very easily. That's a great use case for a lower-level tool like Parcel or purely client-side Vite templates. Maybe your app is a drawing editor, you have no routes, and you want to opt out even from SSG. We always supported, and will support that. It's valid to continue to use React as a library rather than as a framework architecture. We only argue it's not the right default for most new web apps.

If the best way for most React apps is to start with a framework, which framework should we suggest? Should we pick one? How do we decide which one to pick? What if it gets stagnant over time? There is also a more sensitive question of incentives. Popular and well-maintained frameworks often have some kind of commercial offerings related to them — either directly or indirectly. These offerings may fund the development of those frameworks, but we'd like to avoid pushing people towards a product that, for example, only works with a particular hosting platform.

This brings us to the question in this thread.

## What should we do with Create React App?
Create React App's original goals were:

Provide an easy way to start a new React project without configuration.
Integrate compilation-related dependencies to be easily upgradable.
Let the React team deploy tooling updates as broadly as possible (e.g. Fast Refresh support, Hooks lint rules).
However, it doesn't meet the original goal of being the best way to create a React app anymore. By raising the bar and integrating compilation with rendering, routing, and data fetching, frameworks let their users create React apps that:

Take full advantage of web APIs to deliver fast apps and sites by default, whether small or large.
Take full advantage of React itself and its framework-level features.
Provide routing and data fetching that let the developers fall into the "pit of success".
The React ecosystem deserves a default recommended approach that can take full advantage of the web and of React itself. This doesn't even mean necessarily depending on a Node.js server. Many popular frameworks don't require a server and can work in SSG mode, so they can address the "fully static" use cases too. The advantage of a framework is that if you later need SSR, you don't need to migrate. It's available, as are other things (e.g. Remix offers a mutation API out of the box).

How do we achieve this vision? We see a few options.

### Option 1: Create a new framework from scratch
We could try to rearchitect Create React App as a framework that integrates data fetching, routing, bundling, and SSG/SSR. Building a high-quality new framework at the intersection of these concerns is a huge undertaking, requires a lot of specialized ecosystem expertise, and even if we stopped other projects to pull this off, there is a significant risk it would become stagnant over time like Create React App itself did. It would also further fragment the ecosystem with yet another framework that is officially recommended despite having no real users. We don't think this option is practical at this time.

### Option 2: Deprecate Create React App, maintain a Vite template
We could deprecate Create React App and instead maintain our own Vite template. To achieve the stated goals, this template would have to be very sophisticated. In fact, it would have to be as sophisticated as a React framework — and impose opinions about routing, data fetching, etc. That leads to the same issue: we'd effectively be creating another framework.

### Option 3: Deprecate Create React App, suggest React frameworks
We could deemphasize or deprecate Create React App as a tool, and emphasize React frameworks more actively. This doesn't mean you would have to use a framework with React, but that we would suggest using one of them for most apps. The downside is we'd no longer have a neutrally branded CLI "gateway" to creating a React app: you'd have to find the right one in the corresponding framework's docs. Outright deprecating is also disruptive. We'd need to keep the command working for a long while — which is confusing from the branding perspective ("why is creating a React app deprecated?")

### Option 4: Make Create React App use a single framework
We could pick a single designated framework, and change Create React App to create apps with that framework by default. The main problem with this approach is that it makes it very difficult for other solutions to compete — especially if they have slightly different tradeoffs but are roughly the same in popularity, feature set and quality. Such a change in behavior would also have to be pretty disruptive since all the old tutorials would break in a non-obvious way.

### Option 5: Turn Create React App into a launcher
We could keep Create React App as a command, but turn it into a launcher. It would suggest a list of recommended frameworks, followed by the "classic" framework-less approach being the last option. That last "classic" approach would produce a client-only app like CRA does now (to avoid breaking tutorials), but could eventually move to Vite under the hood.

To get on the curated frameworks list, a React framework would have to meet certain criteria — similar to what de facto happens with this documentation page. We would need to consider popularity and adoption in the community (to keep the list short), feature set, performance characteristics, ability to take full advantage of the web platform and React itself, whether it's actively maintained, and whether it is clear how to host it on a variety of hosting services and environments (to avoid any vendor lock-in). The starter template for each framework would be maintained by the React team to ensure they have consistent design and branding, don't link to commercial services, and are similarly structured. We would need to clearly communicate to the community about how we arrived at our choices, and we would periodically reevaluate them.

## Our proposal
We are currently leaning towards Option 5 ("Turn Create React App into a launcher"). The original goal of Create React App was to provide the best way to start a new React web app for the majority of React users. We like that repurposing it as a launcher explicitly communicates a shift in what we think is best for most new web apps, while at the same time leaving an escape hatch for the older workflows. Unlike Option 3, it avoids the perception that "creating a React app" is somehow deprecated. It acknowledges the reality that a bit of choice is needed, but there are now really great options to choose from.

We'll be working on a more detailed RFC proposal fleshing out these points. In the meantime, we'd love to hear your feedback on these points. I know this was a long comment, but I wanted to show the whole thought process, and to use this opportunity to clarify the relationship between React and frameworks. I'll try my best to respond to follow-up questions here.

Thank you for reading!